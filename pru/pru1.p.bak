//
// Assembly language code to run on pru 1
//
// We will 
// - flash led 
// - until button pressed in pru0 then stop
//
//
// TO DO: implement backwards and forewards on the motor controlers
//
// ********************************************************
// Output/Input Layout
// ********************************************************
// GPIO1[28] > LED for user feedback
// GPIO1[16] > Switch for user input
// r30.t0 => PWM output (3-0)
// r30.t1 => PWM output (3-1)
// r30.t2 => PWM output (1-0)
// r30.t3 => PWM output (1-1)
// r30.t4 => PWM output (2-0)
// r30.t5 => PWM output (2-1)
// r30.t6 => PWM output (4-0)
// r30.t7 => PWM output (4-1)
// r31.t8 => ENC_1
// r31.t9 => ENC_2
// r31.t10=> ENC_3
// r31.t11=> ENC_4
//
// *******************************************************
// Register Layout
// *******************************************************
// r0 => stores index i
//
// r1 => counts rising transitions on wheel encoder 1 input
// r2 => counts rising transitions on wheel encoder 2 input
// r3 => counts on wheel encoder 3 input
// r4 => counts on wheel encoder 4 input
//
// r5 => stores the old encoder inputs
// r6 => stores the new encoder inputs
// r12 => stores the encoder ticks edge finder value
// These wil get read in at start of sample period from fro PRU 0
//
// r7 => stores duration high (1 - 8190) for PWM 1
// r8 => stores duration high (1 - 8190) for PWM 2
// r9 => stores duration high (1 - 8190) for PWM 3
// r10 => stores duration high (1 - 8190) for PWM 4
//
// r11 => stores index j
// r16 => Used for GPIO_LED
// r15 => Used for GPIO_BUTTON
// r17 => Used for GPIO1_READ
// r18 => Used for GPIO2_SET
// r19 => Used for GPIO2_CLEAR
// r27 => Used to hold the address value of shared memory 0x00010000 (0x4a310000)
// r29 => used for NOP
//
//
// Pseudo code
//
// START: 
// Turn LED OFF i.e. clr r30.t0
// Clr r1 through 29
// Send interrupt to PRU 0
// Wait for return interrupt from PRU 0
// LOOP: 
// Toggle LED  (GPIO2[16])
// Read in PWM high periods from PRU 0 into r7 - r10
// Turn all 4 PWM outputs ON (r30.t8, r30.t7, r30.t6, r30.t5)
// for (i = 4096, i != 0, i--) {  // use r0 for i
//		read decoder inputs into r6
//		if (posedge on wheel encoder 1) incr r1
//		if (posedge on wheel encoder 4) incr r2
//		if (posedge on wheel encoder 2) incr r3
//		if (posedge on wheel encoder 3) incr r4
//		if (r7  == 0) clr r30.t5   else r7--
//		if (r8  == 0) clr r30.t6   else r8--
//		if (r9  == 0) clr r30.t7   else r9--
//		if (r10 == 0) clr r30.t8   else r10--
//		for (j = DELAY, j != 0, j--) { } // stall
//		r5 = r6 
//		Send interrupt to PRU 0
// }  // Loop should take exactly 50 ms to execute
// if (button press) goto LOOP else HALT
//		

// Don't think we need this but maybe at some point
//Here is how you enable the OCP master port
// Enable the OCP master port -- allows transfer of data to Linux userspace
//
//	LBCO    r0, C4, 4, 4     // load SYSCFG reg into r0 (use c4 const addr)
//	CLR     r0, r0, 4        // clear bit 4 (STANDBY_INIT)
//	SBCO    r0, C4, 4, 4     // store the modified r0 back at the load addr


#include        "./pru1.h"
.origin		0
.entrypoint	START


// Number of times to loop (i.e. 12-bit PWM)






// @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@

//START:			
START:		        
                        zero	&r1, 116				// Clear r1-r29 (29 * 4 = 116 bytes)
                        GPIO_SETUP                                      // Setup Linux space GPIO pointers in registers
// Grab the value we need for our delay loop            
// Host would have written it into location 0 of data memory
// r28 will contain the value
			zero	&r29, 4					// Point at location 0 in data memory
			lbbo	r28, r29, 0, 4				// unsigned int is 4 bytes long

// Use r27 as a pointer to the PRU shared data RAM ($0001_0000)
// That is how we will transfer results to and from PRU 0
			ldi		r27, 1
			lsl		r27, r27, 16
                        LED_TOGGLE

MAIN:			                                         	// toggle bit GPIO2_6 (LED)                       


// Send interrput to PRU 0 to let it know about start of sample period!!!

			ldi		r31, PRU1_PRU0_INTERRUPT + 16
			
// Zero r1-r4

//			zero		&r1, 16			// Zero the wheel encoder counters

// Need to save the wheel encoder input values from past sample period
                        mov		r5, r6			// Copy r6 (new) wheel encoder values to r5 (old)
                       
// Read in R7 - R10 (PWM high times) from PRU0
// For time being just set the r7-r10 registers
// Values will come from first four word locations in shared memory


//			mov		r7, #500
//			mov		r8, #4000
//			mov		r9, #8000
//			mov		r10, #12000
			//accessing memory from pru0

			lbbo	        r7, r27, 0, 16	       // loading r7-r10
//                      mov             r30, 0x0000055         //Make all the primary PWM outputs high 
                                                               //and ground the secondary 

// We will check the wheel encoders 4096 times each sample period (50 ms)
// So we need to do in about 3.05 us

			mov	r0, #TIMES	 		// set i = 4096
	I_LOOP:		mov	r6.b1, r31.b1			// read wheel encoders


// We can find edges by finding r5 xor r6

			//not	r12.b1, r5.b1			// r12 <= ~r5
			//and	r12.b1, r12.b1, r6.b1		// r12 <= r12 & r6
                        xor     r12.b1 , r6.b1, r5.b1

// Wheel encoder #1
        ENC1_1:		qbbc	ENC1_0, r12.b1.t0			// If set to 0 jump to ENC1_0
        		add	r1, r1, 1			// inc posedge counter
                        qba     ENC2_1                          // over delay to next
        ENC1_0:         mov     r29,r29                         //Mimic add
                        mov     r29,r29                         //Mimic qba

// Wheel encoder #2
		
 	ENC2_1:		qbbc	ENC2_0, r12.b1.t1                  // If clr jump ENC_0
			add	r2, r2, #1			// inc posedge count
                        qba     ENC3_1                          // Jump over delay
        ENC2_0:         mov     r29, r29                        //Mimic Add
                        mov     r29, r29                        //Mimic qba
// Wheel encoder #3

        ENC3_1:		qbbc	ENC3_0, r12.b1.t2
			add	r3, r3, 1
//                        qbeq    SKIP,r3, 255			// inc posedge counter
			qba	ENC4_1
	ENC3_0:		mov	r29, r29			// nop	
                        mov     r29, r29	

// Wheel encoder #4
		
 	ENC4_1:		qbbc	ENC4_0, r12.b1.t3
			add	r4, r4, #1			// inc posedge counter
			qba	PWM1_0
	ENC4_0:		mov	r29, r29			// nop
                        mov     r29, r29 
                        		
// PWM output #1

	PWM1_0:		qbne	PWM1_1, r7, 0			// Time to low? if yes bring low if not dec counter
			clr	r30.t2				// 	Bring output low
			qba	PWM2_0				// 	Jump to next PWM
	PWM1_1:		sub	r7, r7, 1			// else Dec pwm high counter
			mov	r29, r29			// 	nop (Mimic Jump)

// PWM output #2

	PWM2_0:		qbne	PWM2_1, r8, 0			// Time to go low?
			clr	r30.t4				// Bring output low
			qba	PWM3_0				
	PWM2_1:		sub	r8, r8, 1			// Dec pwm high counter
			mov	r29, r29			// nop

// PWM output #3

	PWM3_0:		qbne	PWM3_1, r9, 0			// Time to go low?
			clr	r30.t0				// Bring output low
			qba	PWM4_0
	PWM3_1:		sub	r9, r9, 1			// Dec pwm high counter
			mov	r29, r29			// nop

// PWM output #4

	PWM4_0:		qbne	PWM4_1, r10, 0			// Time to go low?
			clr	r30.t6				// Bring output low
			qba	TIMEKILL			// Jump to the timeKiller -  done with PWM
	PWM4_1:		sub	r10, r10, 1			// Dec pwm high counter
			mov	r29, r29			// nop

// Kill some time before going back around
// First clear the LED
             
	TIMEKILL:	mov	r11, r28			// store the length of delay in r11 (j)
	J_LOOP:		sub	r11, r11, 1			// Dec r11
			qbne	J_LOOP, r11, 0
                        mov     r1, 0x50505050
// Save the encoder counter values to shared memory
			sbbo	&r1, r27, 16, 16		// save r1-r4 to memory after the 4 PWM values 
// i loop               
			sub	r0,	r0, 1			// Dec i
			qbne	I_LOOP, r0, 0

// If user button pressed, then let ARM know we are halting and then halt!
	//AT THE MOMENT JUST BRANCH UNCONDITIONALLY TO MAIN AND CONTUINE THIS LOOP	
			//Need to add code here to poll the GPIO right now we are just going 
			//branch unconditionally and wait for the kernal to halt the pru
	        	//qbbc	MAIN, r31.t9
                        		
                        BUTTON_CHK
                        LED_TOGGLE
                        qbbc   MAIN, GPIO_BUTTON.b1.t7            			
SKIP:                   mov    r30, 0x00000000          //Set PWM's to low 	        	
                        LED_OFF
                        mov 	r31.b0, PRU_R31_VEC_VALID | PRU_EVTOUT_1	
                        halt	



/*
                        set     GPIO_LED.t15
                        sbbo    GPIO_LED, set_gpio2, 0, 4
MAIN:                   ldi             r31, PRU1_PRU0_INTERRUPT + 16
TIMEKILL:               mov     r11, r28                        // store the length of delay in r11 (j)
J_LOOP:                 sub     r11, r11, 1                     // Dec r11
                        qbne    J_LOOP, r11, 0
                        BUTTON_CHK
                        qbbc    MAIN, GPIO_BUTTON.t15
                        //LED_TOGGLE
                        set     GPIO_LED.t15
                        sbbo    GPIO_LED,r19, 0, 4
                        mov     r31.b0, PRU_R31_VEC_VALID | PRU_EVTOUT_1
                        halt    

*/                       
        
		
